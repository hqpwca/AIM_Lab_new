#实验1：从Hello, World开始

##绪言
> 操作系统，自实验接触计算机以来就已经出现的一个名词。其具体在实验的实际使用过程中，做了哪些工作，相信在经过第一阶段的学习后，对此有已经有所了解。但在本节实验中，实验将先抛弃之前所学的内容，从最简单的 Hello, World 程序开始，展开操作系统这一概念。

##实验目标
* 了解`Hello, World`程序对操作系统的依赖
* 掌握如何将程序在无操作系统支持的裸机（baremetal）上运行
* 简要了解 UART 串口的概念，学会使用汇编代码进行串口输出
* 根据已有的代码框架，实现可在 QEMU（i386架构）上直接执行的 Hello, World

##交流讨论
###Hello，World 对操作系统有哪些依赖？

##背景知识
###实验将在什么架构上实现？
在不涉及实际操作系统的编写阶段，实验将使用最常见的 i386 架构实现 Hello, World 等基础代码（当然，也欢迎在了解程序原理的情况下，自行实现非 i386 架构的代码）。在具体进入RAIM系统的编写过程后，将采用分组的形式，实现 RISCV，ARM，i386，MIPS 四种不同架构的操作系统。

###如何将程序在无操作系统的情况下运行？
操作系统的被装载运行时通常是以 ELF 等较为复杂的格式存在的，装载的流程在不同平台上也有较大的差异。本次实验中，在 i386 平台上，板载的 BIOS 作为设备固件首先运行，它读取硬盘的 0 号扇区至内存中指定位置（一般为内存 0x7f00 地址处），检查其 magic number 后直接跳转运行。

为此，实验需要编写直接面向机器的程序（常常称为 baremetal）。这类程序编译和链接时几乎不使用开发环境提供的库和头文件，并且需要单独写脚本显式控制链接器的行为，即实现链接器脚本（linker script），但在整个课程的实验中不需要实现这一部分。

> linker script 的具体结构较为复杂，且由于`ld`的相关文档处于没有开发者维护的状态，大多都已经 outdated ，因此实验不要求自行实现链接器脚本。
> 
> 在每次实验的 code base 发布时，将会附带当前实验匹配的链接器脚本（一般为`.lds`文件)。在本次实验中，使用`gcc`的相关参数对其进行调用即可。后续实验会附带相关的`Makefile`文件，将会自动使用自带的链接器脚本。
> 
> 如果希望能够自行实现链接器脚本，或所需的变量等在已有的链接器脚本中不能得到满足，可以自行编写合适的链接器脚本完成实验，具体实现方式可以参考已有的链接器脚本文件，`ld`的相关文档，以及附录中的链接器脚本的简易手册。

尽管实验中不需要实现链接器脚本，但需要了解其原理与使用过程，这对之后编写操作系统的汇编部分时有很大的帮助，这部分可以参考`ld`的[在线文档](https://sourceware.org/binutils/docs/ld/Scripts.html)，以及`gcc`的[在线文档](https://gcc.gnu.org/onlinedocs/gcc/)的内容。

在实现链接器脚本之后，实验需要将所编译的二进制文件实际在实际的计算机中执行。为此，实验中使用入门最为简单的虚拟机`qemu`对实际计算机进行模拟。

`qemu`的[官方文档](https://qemu.weilnetz.de/doc/qemu-doc.html)中有对`qemu`的完整介绍。其中实验中具体使用的参数为 `-cpu` `-m` `-hda` `-serial` `-nographic` 等。需要使用`gdb`时可以参考文档的2.14节 GDB Usage 。

###BIOS怎样识别一个设备能否启动？
如上一个问题开头所叙述的那样，BIOS在读取一个设备的0号扇区后，将会检查 magic number 的存在性。magic number 即在该扇区的最后两个字节处的特定标示。在 i386 架构的机器上，magic number 为 `0x55` 与 `0xaa`，分别在该扇区的第511与第512字节处。

通过 gcc 编译出的汇编代码，由于其中存在 elf 头部分，且具体文件中，代码的偏移量不确定，因此，我们需要通过 objcopy 指令，将我们需要执行的代码提取出来。具体指令如下：
`objcopy -O binary (ELF Filename) (BIN Filename)`

通过这一指令，可以将代码的可执行部分从编译完成的elf格式的可执行文件中提取出来。之后，我们需要将代码扩展到1个扇区大小（512字节）并在最后两个字节处加入 magic number，这一过程可以通过各种二进制编辑器进行。如果不想使用可视化的二进制编辑器，也可以使用 dd 指令进行代码大小的扩展，通过 vim 的二进制编辑功能加入 magic number。

显然。由于BIOS只读取0号扇区，因此，我们的代码长度不能过长，即不能超过1个扇区的大小512字节，在代码编写时需要注意。

###在无操作系统的情况下，如何将字符输出到屏幕上？

Hello，World这一程序中，实验中所需要做的看似非常简单，即将字符串输出到屏幕上。但这一简单的操作，在离开操作系统后，就会变的相当困难。这一困难最主要的来源是：实验没有合适的途径访问屏幕进行输出。

在实际的操作系统中，实验中输出一串字符需要通过显示驱动，终端等多个部分。为了体会操作系统的工作量，实验将用极为简化的方式，实现输出字符这一操作。抛去终端等大量用户友好相关实现，仅最小限度的实现驱动部分，完成在裸机上输出 Hello, World. 的目标。

为此，实验中选择qemu可以直接转为屏幕输出的串口，实现其初始化以及输出部分。其中，初始化部分在 code base 中已经实现，我们只需要实现 `port_out` 函数，使用cpu的设备控制器对相应的端口进行输出即可。

`qemu`的 i386 部分自带的串口型号为 UART 16550 ，其使用近似于 UART 8250 串口，具体输入输出部分可以参考[文档](https://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming)。具体端口输出使用 i386 的 `out` 指令，具体见 x86 manual。

在实现串口输出之后，我们可以通过qemu的参数`-serial`将串口映射到屏幕输出上。具体可参见 QEMU 文档。

##课后实验
###实验准备
1. 从 github 上获取实验1的 code base
2. 安装 qemu （部分linux系统自带）

###实验过程
1. 根据本节课所学的内容，填充`helloworld.c`中的`TODO`部分。
2. 阅读`gcc`编译器相关文档，选择合适的命令调用附带的链接器脚本`helloworld.lds`，并取消libc基本库的使用，将代码编译为二进制形式，注意编译时加入`uart.o`文件，以便使用提供的串口初始化函数。（注意，i386架构默认运行在16位模式下，因此在编译时需要加入编译选项`-m16`）
3. 使用 `objcopy` 工具，提取可执行代码段，并加入 magic number ，使 BIOS 能够识别。
4. 使用`qemu`调用所处理的二进制代码实际执行，并将串口输出的 Hello, World 显示在屏幕上。(提示：关闭QEMU可使用 `Ctrl^A + X`指令）

###实验提交
将执行的命令编写为`run.sh`文件，与所修改过的 code base 打包后，提交到elearning上即可。要求在做好实验准备的计算机上，执行`run.sh`可以直接输出字符串 Hello, World 。

完成基础实验后，将会获得这次实验80分的基础分数，若想要得到更多的分数，可以完成每次实验后的思考部分，获得额外加分（最多不超过100分）。

##思考
1. 如何初始化 UART 端口？在查阅资料后，不调用`uart.o`文件中的`uart_16550_init()`函数，自行编写 UART 端口的初始化部分。（20分）

2. 如何使用`gdb`对在`qemu`中运行的程序进行调试？使用调试功能并提供相关截图。（10分）

3. 使用`objdump`与`readelf`对代码进行分析，将分析结果输出到同名的文本文件中。（10分）

